# 8
Quicksort
Массив из 5 элементов: 1 3 2 6 4
1)Вычисляем опорный: p_ind=2 =>piv=2
I=first=0; j=last=n-1=4
2)Заходим в do while(i <=j)
3)Заходим в while по i
i не равно индексу piv и arr[i]<piv ? Да, 0!=2 и 1<2, т.к I<j (0<4) => sravn++( кол-во сравнений:1) увеличиваем I

i не равно индексу piv и arr[i]<piv ? Нет, 1!=2 но 3>2, заходим в if. i!p_ind и I<j ? Да, 1!=2 и 1<4 => sravn++(кол-во сравнений:2)

4)Заходим в while по j
j не равно индексу piv и arr[j]>piv? Да, 4!=2 и 4>2, т.к I<j (1<4) =>sravn++( кол-во сравнений:3) уменьшаем j

j не равно индексу piv и arr[j]>piv? Да,3!=2 и 6>2, т.к I<j (1<3) =>sravn++( кол-во сравнений:4) уменьшаем j

j не равно индексу piv и arr[j]>piv? Нет, 2=2 и 6>2, заходим в if. j!p_ind и i<j ? Нет, 2=2

5)Заходим в if(I<=j) (т.к 1<2)
I!=j ? Да, 1!=2 , значит меняем arr[i] и arr[j] => perest++
Изменённый массив: 1 2 3 6 4
уменьшаем j и увеличиваем I
I<=j? Нет(2>1), выходим do while

6)I<last, (2<4) да, вызываем quicksort(arr, 2, 4)

7) Вычисляем опорный: p_ind=3 =>piv=6
I=first=2; j=last=4

8)Заходим в while по i
i не равно индексу piv и arr[i]<piv ? Да, 2!=3 и 3<6, т.к I<j (2<4) => sravn++( кол-во сравнений:5) увеличиваем I

i не равно индексу piv и arr[i]<piv ? Нет, 3=3, заходим if. i!p_ind и I<j ? Нет, 3=3

9) Заходим в while по j
j не равно индексу piv и arr[j]>piv? Нет, 4!=3, но 4<6 заходим в if. j!p_ind и i<j ? Да, 4!=3 и 3<4 => sravn++( Кол-во сравнений: 6)

10)Заходим в if(I<=j) (т.к 3<=4)
I!=j ? Да, 3!=4 , значит меняем arr[i] и arr[j] => perest++ (кол-во перест:2)
Изменённый массив: 1 2 3 4 6
уменьшаем j и увеличиваем I
I<=j? Да, (4<=4) , значит

11)Заходим в while по i
i не равно индексу piv и arr[i]<piv ? Нет, 4!=3, но 6>4, заходим в if. i!p_ind и I<j ? Нет, 4!=3, но 4 не меньше 4

12) Заходим в while по j
j не равно индексу piv и arr[j]>piv? Да, 4!=3, 6>4, но I=j, значит уменьшаем j и заходим в if. j!p_ind и i<j ? Нет, т.к 3=3 и 4>3
Не заходим в if(I<=j), т.к 4>3
Выходим из do while

13)I<last? Нет, 4=4; j>first? Да, 3>2 вызываем quicksort(arr, 2,3)

14) Вычисляем опорный: p_ind=2 =>piv=3
I=first=2; j=last=3

15) Заходим в do while(i <=j)
16)Заходим в while по i
i не равно индексу piv и arr[i]<piv ? Нет, индексы равны, заходим в if. i!p_ind и I<j ? Нет, индексы равны
17)Заходим в while по j
j не равно индексу piv и arr[j]>piv?
Да, 3!=2, 4>3. I<j? Да, (2<3) => sravn++ (кол-во сравнений 7), уменьшаем j

j не равно индексу piv и arr[j]>piv? Нет, индексы равны, заходим в if. j!p_ind и i<j ? Нет, т.к 2=2
Заходим в if(I<=j), т.к 2=2, т.к I=j ничего не меняем, увеличиваем I, уменьшаем j
Т.к 3>1 выходим из do while

18)I<last? Нет(3=3) , j >first. Нет( 1<2), значит возвращаемся к первому рекурсивному вызову и вызываем вызываем quicksort(arr, 0,1)( т.к j>first (1>0)
19) Вычисляем опорный: p_ind=0=> piv=1
I=first=0; j=last=1

20) Заходим в do while(i <=j)
21)Заходим в while по i
i не равно индексу piv и arr[i]<piv ? Нет, индексы равны, заходим в if. i!p_ind и I<j ? Нет, индексы равны
22)Заходим в while по j
j не равно индексу piv и arr[j]>piv?
Да, 1!=0 и 2>1. I<j? Да, (0<1)=> sravn++ (кол-во сравнений 8), уменьшаем j

j не равно индексу piv и arr[j]>piv? Нет, индексы равны, заходим в if. j!p_ind и i<j ? Нет, т.к 0=0
Заходим в if(I<=j), т.к 0=0, т.к I=j ничего не меняем, увеличиваем I, уменьшаем j
Т.к 1>-1 выходим из do while

23)I<last? Нет(1=1) , j >first. Нет( -1<0), рекурсивно ничего не вызываем =>

Отсортированный массив
1 2 3 4 6
Перестановок:2
Сравнений:8

Insertsort
Массив 1 3 2 6 4
1)Заходим в for i=1, k=arr[1]=3; j=1-1=0; sravn++(Кол-во сравнений:1)
не заходим в while т.к arr[0]<k( 1<3)
arr[0+1]=к => arr[1]=3
2) Заходим в for i=2; k=arr[2]=2; j=2-1=1; sravn++(Кол-во сравнений:2)
заходим в while т.к 1>=0 и arr[1]>k( 3>2)
=>perest++(Кол-во перестановок:1); arr[2]=arr[1]; j=1-1=0;
Массив: 1 3 3 6 4
arr[0+1]=к => arr[1]=2
Массив : 1 2 3 6 4
3) Заходим в for i=3; k=arr[3]=6; j=3-1=2; sravn++(Кол-во сравнений:3)
не заходим в while т.к arr[2]<k( 3<6)
arr[2+1]=к => arr[3]=6
4) Заходим в for i=4; k=arr[4]=4; j=4-1=3; sravn++(Кол-во сравнений:4)
заходим в while т.к 3>=0 и arr[3]>k( 6>4) =>perest++(Кол-во перестановок:2) arr[3+1]=arr[3]; j=3-1=2;
Массив: 1 3 3 6 6
arr[2+1]=к => arr[3]=4
Массив : 1 2 3 4 6
Кол-во перестановок:2
Кол-во сравнений:4
